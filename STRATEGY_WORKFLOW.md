# 量化交易系统策略流程说明

## 系统架构概览

```
┌──────────────────────────────────────────────────────────────────┐
│                         量化交易系统                                │
└──────────────────────────────────────────────────────────────────┘

┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│ MarketData   │────▶│ Strategy     │────▶│ RiskControl  │
│  行情模块     │     │  Engine      │     │  风控模块     │
│              │     │  策略引擎     │     │              │
└──────────────┘     └──────────────┘     └──────────────┘
       │                    │                    │
       │                    ▼                    ▼
       │            ┌──────────────┐     ┌──────────────┐
       │            │   Signal     │     │   Order      │
       │            │   交易信号    │     │   订单       │
       │            └──────────────┘     └──────────────┘
       │                                       │
       └───────────────────────────────────────┼
                                                ▼
                                         ┌──────────────┐
                                         │ OrderExecutor│
                                         │  执行模块     │
                                         └──────────────┘
                                                │
                                                ▼
                                         ┌──────────────┐
                                         │  Exchange    │
                                         │  交易所 API  │
                                         └──────────────┘
```

---

## 一、策略生命周期

### 1.1 策略初始化流程

```
┌─────────────────────────────────────────────────────────────┐
│ 1. 策略初始化                                               │
└─────────────────────────────────────────────────────────────┘
   │
   ├─▶ 创建 StrategyConfig（风险比例、冷却期、止损参数等）
   │
   ├─▶ 实例化策略（如 HFVSStrategy）
   │   ├─ 初始化技术指标（RSI, ATR, EMA等）
   │   ├─ 初始化配置参数（从 config.properties 读取）
   │   ├─ 初始化状态变量（持仓计数、入场ATR等）
   │   └─ 初始化日志记录器
   │
   ├─▶ 注册到 StrategyEngine
   │
   └─▶ 策略进入就绪状态，等待K线数据
```

**关键代码：**
```java
// 创建策略
HFVSStrategy strategy = new HFVSStrategy(
    Symbol.of("BTCUSDT"),
    Interval.FIVE_MINUTES,
    StrategyConfig.builder()
        .riskPerTrade(BigDecimal.valueOf(0.01))
        .cooldownBars(3)
        .build()
);

// 注册到引擎
strategyEngine.addStrategy(strategy);
```

---

### 1.2 K线数据处理流程（回测/实盘）

```
┌─────────────────────────────────────────────────────────────┐
│ 2. K线数据到达（每5分钟一根）                                 │
└─────────────────────────────────────────────────────────────┘
   │
   ├─▶ 【回测】BacktestEngine 模拟逐根K线推送
   │   └─ 从历史数据中按时间顺序取下一根K线
   │
   └─▶ 【实盘】MarketDataManager 通过 WebSocket 接收
       └─ Binance WebSocket 推送实时K线数据
```

**数据处理步骤：**

```
┌──────────────────────────────────────────────┐
│ Step 1: 检查持仓止损                          │
└──────────────────────────────────────────────┘
   │
   └─▶ BacktestEngine.checkStopLoss(kLine)
       ├─ 遍历所有持仓
       ├─ 检查价格是否触发止损价
       ├─ 触发 → 平仓
       └─ 未触发 → 继续

┌──────────────────────────────────────────────┐
│ Step 2: 更新持仓状态（关键）                  │
└──────────────────────────────────────────────┘
   │
   └─▶ BacktestEngine.checkPositionUpdates(kLine, allKLines)
       ├─ 遍历所有持仓
       ├─ 调用 strategy.onPositionUpdate(position, currentKLine, allKLines)
       │   │
       │   ├─ 【重要】重新计算技术指标（RSI、ATR、EMA等）
       │   │   └─ 使用完整历史数据 allKLines，而非单根K线
       │   │
       │   ├─ 检查出场条件：
       │   │   ├─ RSI 回归止盈（RSI ∈ [45,55]）
       │   │   ├─ 时间止损（持仓 >= 20根K线）
       │   │   └─ 风控止损（浮亏 >= 止损线）
       │   │
       │   ├─ 满足出场条件 → 返回 Exit Signal
       │   └─ 不满足 → 返回 null
       │
       ├─ 收到 Exit Signal → 平仓
       └─ 未收到 → 继续

┌──────────────────────────────────────────────┐
│ Step 3: 策略分析（生成入场信号）              │
└──────────────────────────────────────────────┘
   │
   └─▶ strategy.analyze(availableKLines)
       │   availableKLines = 从开始到当前的所有K线
       │
       ├─ 数据完整性检查
       │   └─ 至少需要 60 根K线（保证 EMA60 计算正确）
       │
       ├─ 检查冷却期
       │   └─ 上次交易后是否已过 3 根K线？
       │       ├─ 否 → 返回 null（跳过本根K线）
       │       └─ 是 → 继续
       │
       ├─ 适用性判断（ATR 分位数过滤）
       │   ├─ 计算当前 ATR 在历史分布中的分位数
       │   ├─ 分位数是否在 [30%, 70%] 区间？
       │   │   ├─ 否 → 返回 null（市场波动不适用）
       │   │   └─ 是 → 继续
       │   │
       │   └─ 【注意】样本不足时允许交易（预热期）
       │
       ├─ 提取价格数据
       │   ├─ closes = [close1, close2, ..., closeN]
       │   ├─ highs = [high1, high2, ..., highN]
       │   └─ lows = [low1, low2, ..., lowN]
       │
       ├─ 计算技术指标
       │   ├─ RSI(14) = rsi.latest(closes)
       │   ├─ ATR(14) = atr.latest(highs, lows, closes)
       │   ├─ EMA(20) = ema20.latest(closes)
       │   ├─ EMA(60) = ema60.latest(closes)
       │   └─ 更新 ATR 分位数跟踪器
       │
       ├─ 判断进场条件
       │   │
       │   ├─ 【做多条件】
       │   │   ├─ RSI < 30 (超卖)
       │   │   ├─ 价格 < EMA20 (低于均线)
       │   │   ├─ |价格 - EMA20| > 2.0 × ATR (远离均线)
       │   │   └─ EMA20 > EMA60 (上升趋势确认)
       │   │       └─ 全部满足 → 生成 LONG 信号
       │   │
       │   └─ 【做空条件】
       │       ├─ RSI > 70 (超买)
       │       ├─ 价格 > EMA20 (高于均线)
       │       ├─ |价格 - EMA20| > 2.0 × ATR (远离均线)
       │       ├─ EMA20 < EMA60 (下降趋势确认)
       │       └─ 全部满足 → 生成 SHORT 信号
       │
       ├─ 生成进场信号
       │   ├─ 计算止损价 = 开仓价 ± (ATR × 2.0)
       │   ├─ 计算仓位大小 = (账户余额 × 1%) / 止损距离
       │   ├─ 记录交易（更新冷却期计数器）
       │   ├─ 记录日志
       │   └─ 返回 Signal
       │
       └─ 无进场条件 → 返回 null

┌──────────────────────────────────────────────┐
│ Step 4: 风控检查                             │
└──────────────────────────────────────────────┘
   │
   └─▶ RiskControl.validateAndCreateOrder(signal)
       ├─ 账户余额充足性
       │   └─ 余额 >= 保证金 + 手续费？
       │       ├─ 否 → 拒绝订单
       │       └─ 是 → 继续
       │
       ├─ 连续亏损限制
       │   └─ 连续亏损次数 >= 5？
       │       ├─ 是 → 拒绝订单，触发紧急停止
       │       └─ 否 → 继续
       │
       ├─ 回撤限制
       │   └─ 当前回撤 >= 30%？
       │       ├─ 是 → 拒绝订单，触发紧急停止
       │       └─ 否 → 继续
       │
       ├─ 持仓限制
       │   └─ 已有该交易对持仓？
       │       ├─ 是 → 拒绝订单
       │       └─ 否 → 继续
       │
       ├─ 止损距离合理性
       │   └─ 止损距离在合理范围？
       │       ├─ 否 → 拒绝订单
       │       └─ 是 → 继续
       │
       └─ 自动计算仓位大小
           └─ positionSize = (账户余额 × 1%) / 止损距离
               └─ 返回 Order 对象

┌──────────────────────────────────────────────┐
│ Step 5: 订单执行                             │
└──────────────────────────────────────────────┘
   │
   ├─▶ 【回测】BacktestEngine.enterPosition(signal, kLine)
   │   ├─ 应用滑点（0.05%）
   │   ├─ 创建持仓对象
   │   ├─ 添加到持仓列表
   │   └─ 更新权益曲线
   │
   └─▶ 【实盘】OrderExecutor.submitOrder(order)
       ├─ 幂等性检查（防止重复提交）
       ├─ 调用 Exchange.placeOrder(order)
       │   └─ ⚠️ 当前未实现，返回 UnsupportedOperationException
       ├─ 持久化订单（JSON 格式）
       └─ 更新订单状态
```

---

## 二、持仓管理流程（详细）

### 2.1 持仓期间指标更新机制

```
┌─────────────────────────────────────────────────────────────┐
│ 持仓期间每根K线的处理流程                                    │
└─────────────────────────────────────────────────────────────┘

   K线到达
     │
     ▼
┌────────────────────────────┐
│ onPositionUpdate 被调用    │
│ (每根K线自动调用一次)       │
└────────────────────────────┘
     │
     ├─ 传入参数：
     │   ├─ position: 当前持仓对象
     │   ├─ currentKLine: 当前这根K线
     │   └─ allKLines: 从开始到现在的完整历史 ⚠️ 重要
     │
     ▼
┌────────────────────────────┐
│ 1. 递增持仓计数器          │
│   holdingBars++            │
└────────────────────────────┘
     │
     ▼
┌────────────────────────────┐
│ 2. 重新计算所有技术指标     │
│   （使用完整历史数据）       │
└────────────────────────────┘
     │
     ├─ 提取价格序列
     │   ├─ closes = extractCloses(allKLines)
     │   ├─ highs = extractHighs(allKLines)
     │   └─ lows = extractLows(allKLines)
     │
     ├─ 计算实时指标值
     │   ├─ currentRSI = rsi.latest(closes)
     │   ├─ currentATR = atr.latest(highs, lows, closes)
     │   ├─ currentEMA20 = ema20.latest(closes)
     │   └─ currentEMA60 = ema60.latest(closes)
     │
     └─ ⚠️ 关键：不要使用缓存的旧值！
         每次都重新计算，确保指标值是最新的
     │
     ▼
┌────────────────────────────┐
│ 3. 检查出场条件（按优先级） │
└────────────────────────────┘
     │
     ├─ 【优先级1】RSI回归止盈
     │   │
     │   ├─ 条件判断：
     │   │   ├─ 持仓 >= 15根K线？
     │   │   └─ RSI ∈ [45, 55]？
     │   │       └─ 是 → 触发止盈
     │   │
     │   ├─ 出场逻辑：
     │   │   ├─ 记录止盈原因
     │   │   ├─ 生成 Exit Signal
     │   │   ├─ 重置持仓计数器
     │   │   └─ 返回信号
     │   │
     │   └─ 日志示例：
     │       "RSI回归止盈: RSI=52.60∈[45,55],
     │        持仓15根K线, 浮盈=68.47"
     │
     ├─ 【优先级2】时间止损（强制）
     │   │
     │   ├─ 条件判断：
     │   │   └─ 持仓 >= 20根K线？
     │   │       └─ 是 → 强制出场
     │   │
     │   ├─ 出场逻辑：
     │   │   ├─ 记录时间止损原因
     │   │   ├─ 生成 Exit Signal
     │   │   ├─ 重置持仓计数器
     │   │   └─ 返回信号
     │   │
     │   └─ 日志示例：
     │       "时间止损: 持仓20根K线 >= 限制20根,
     │        价格=87881.30, 浮盈=117.24"
     │
     └─ 【优先级3】风控止损（兜底）
         │
         ├─ 条件判断：
         │   └─ 浮亏 <= -maxLoss？
         │       └─ 是 → 紧急出场
         │
         ├─ 出场逻辑：
         │   ├─ 记录风控原因
         │   ├─ 生成 Exit Signal
         │   ├─ 重置持仓计数器
         │   └─ 返回信号
         │
         └─ 日志示例：
             "风控止损: 浮盈=-25.30 <= 止损线20.00,
              持仓3根K线"

     如果所有条件都不满足 → 返回 null，继续持仓
```

### 2.2 出场优先级逻辑

```
出场条件优先级（从高到低）：

┌────────────────────────────────────────────────────────┐
│ 1️⃣ RSI回归止盈（优先）                                │
│    - 目标：快速兑现利润                                 │
│    - 条件：持仓 >= 15根K线 AND RSI回到[45,55]区间       │
│    - 示例：进场时RSI=25，当前RSI=50 → 出场              │
└────────────────────────────────────────────────────────┘
              │
              ▼ （未触发）
┌────────────────────────────────────────────────────────┐
│ 2️⃣ 时间止损（强制）                                    │
│    - 目标：避免长期套牢                                 │
│    - 条件：持仓 >= 20根K线（100分钟）                   │
│    - 示例：持仓20根K线，无论盈亏都强制出场              │
└────────────────────────────────────────────────────────┘
              │
              ▼ （未触发）
┌────────────────────────────────────────────────────────┐
│ 3️⃣ 风控止损（兜底）                                    │
│    - 目标：限制最大亏损                                 │
│    - 条件：浮亏 >= ATR × 2.0                           │
│    - 示例：浮亏-25.30 <= 止损线-20.00 → 紧急出场        │
└────────────────────────────────────────────────────────┘
```

---

## 三、关键数据流

### 3.1 K线数据流

```
┌─────────────────────────────────────────────────────────────┐
│ K线数据流（从开始到现在的累积）                              │
└─────────────────────────────────────────────────────────────┘

时间序列：
 t0      t1      t2      ...     t(n-1)      tn        t(n+1)
 │       │       │               │           │          │
 K0      K1      K2              K(n-1)      Kn        K(n+1)
 │       │       │               │           │          │
 └───────┴───────┴───────┬───────┴───────┴──────────┘
                         │
                         ▼
              availableKLines (累积)
              [K0, K1, K2, ..., Kn]
                    │
                    ├─▶ analyze(availableKLines)
                    │   └─ 获取完整历史，计算指标，生成进场信号
                    │
                    └─▶ onPositionUpdate(pos, Kn, availableKLines)
                        └─ 获取完整历史，重新计算指标，生成出场信号
```

**关键点：**
- `availableKLines` 始终包含从开始到当前的所有K线
- `analyze()` 和 `onPositionUpdate()` 都使用这个完整历史
- 指标计算时从完整历史中提取价格序列

### 3.2 指标计算数据流

```
┌─────────────────────────────────────────────────────────────┐
│ 技术指标计算流程                                            │
└─────────────────────────────────────────────────────────────┘

availableKLines (25920根K线)
     │
     ▼
extractCloses(allKLines)
     │
     ▼
List<BigDecimal> closes = [50000.50, 50100.20, ..., 95677.90]
                             │
                             ▼
                    ┌────────────────┐
                    │  RSI.latest()  │
                    │  ATR.latest()  │
                    │ EMA20.latest() │
                    │ EMA60.latest() │
                    └────────────────┘
                             │
                             ▼
                     BigDecimal currentValue
                     (RSI=47.82, ATR=120.45, ...)
```

**指标类的实现方式：**
```java
// 指标类是无状态的，每次调用都重新计算
public class RSI {
    private final int period;

    public BigDecimal latest(List<BigDecimal> prices) {
        // 从头开始计算整个RSI序列
        // 返回最新的RSI值
    }
}

// 使用示例
RSI rsi = new RSI(14);
BigDecimal currentRSI = rsi.latest(closes);  // 每次都重新计算
```

---

## 四、风险控制流程

### 4.1 多层风控机制

```
┌─────────────────────────────────────────────────────────────┐
│ 多层风险控制（从内到外）                                     │
└─────────────────────────────────────────────────────────────┘

第1层：策略层面风控
├─ ATR 动态止损（ATR × 2.0）
├─ 时间止损（20根K线）
├─ RSI回归止盈
└─ 目标：单笔交易风险控制在 1-2%

第2层：RiskControl 全局风控
├─ 连续亏损限制（5次）
├─ 最大回撤限制（30%）
├─ 单笔风险限制（1%）
├─ 持仓数量限制（每交易对1个）
└─ 目标：保护账户整体安全

第3层：紧急停止机制
├─ 触发条件：
│   ├─ 连续亏损 >= 5次
│   ├─ 当前回撤 >= 30%
│   └─ 手动触发
└─ 行动：
    ├─ 停止所有新交易
    ├─ 禁用所有策略
    └─ 保留持仓管理能力
```

### 4.2 订单风险评估流程

```
┌─────────────────────────────────────────────────────────────┐
│ RiskControl.validateAndCreateOrder()                        │
└─────────────────────────────────────────────────────────────┘

   Signal (交易意图)
     │
     ▼
┌─────────────────────┐
│ 1. 余额检查          │
│ balance >= margin?  │
└─────────────────────┘
     │
     ├─ 否 → REJECT (余额不足)
     │
     └─ 是 → 继续
           │
           ▼
┌─────────────────────┐
│ 2. 连续亏损检查      │
│ losses >= 5?        │
└─────────────────────┘
     │
     ├─ 是 → REJECT (触发紧急停止)
     │
     └─ 否 → 继续
           │
           ▼
┌─────────────────────┐
│ 3. 回撤检查          │
│ drawdown >= 30%?    │
└─────────────────────┘
     │
     ├─ 是 → REJECT (触发紧急停止)
     │
     └─ 否 → 继续
           │
           ▼
┌─────────────────────┐
│ 4. 持仓检查          │
│ 已有该币种持仓?      │
└─────────────────────┘
     │
     ├─ 是 → REJECT (已有持仓)
     │
     └─ 否 → 继续
           │
           ▼
┌─────────────────────┐
│ 5. 止损合理性检查     │
│ 止损距离合理?        │
└─────────────────────┘
     │
     ├─ 否 → REJECT (止损太近或太远)
     │
     └─ 是 → 继续
           │
           ▼
┌─────────────────────┐
│ 6. 自动计算仓位      │
│ size = (balance×1%) │
│        / stopDist   │
└─────────────────────┘
     │
     └─▶ 返回 Order 对象
```

---

## 五、回测执行流程

### 5.1 完整回测流程

```
┌─────────────────────────────────────────────────────────────┐
│ BacktestEngine.run()                                        │
└─────────────────────────────────────────────────────────────┘

   1. 加载历史数据
      │
      ├─ 从 Exchange API 获取
      ├─ 时间范围：2024-10-01 ~ 2024-12-30
      ├─ K线周期：5分钟
      └─ 总K线数：25920根（约3个月）
      │
      ▼
   2. 初始化策略
      │
      ├─ 调用 strategy.reset()
      ├─ 重置所有状态变量
      └─ 清空持仓列表
      │
      ▼
   3. 逐根K线模拟
      │
      ├─ FOR i = 0 TO kLines.size()-1:
      │   │
      │   ├─ KLine kLine = kLines[i]
      │   ├─ List<KLine> availableKLines = kLines[0...i]
      │   │
      │   ├─ checkStopLoss(kLine)
      │   ├─ checkPositionUpdates(kLine, availableKLines)
      │   ├─ Signal signal = strategy.analyze(availableKLines)
      │   ├─ IF signal != null: processSignal(signal, kLine)
      │   └─ updateEquity(kLine.close)
      │
      ▼
   4. 平掉所有持仓
      │
      └─ closeAllPositions(finalPrice)
      │
      ▼
   5. 生成回测报告
      │
      ├─ 总收益率
      ├─ 年化收益率（CAGR）
      ├─ 最大回撤
      ├─ 夏普比率
      ├─ 胜率
      ├─ 盈亏比
      ├─ 平均盈利/亏损
      └─ 资金曲线
```

### 5.2 回测数据质量检查

```
┌─────────────────────────────────────────────────────────────┐
│ 可选：validateKLineData(kLines)                            │
└─────────────────────────────────────────────────────────────┘

检查项：
├─ 数据完整性
│   └─ K线数量 > 0？
│
├─ 时间连续性
│   └─ 检测K线缺口（时间间隔异常）
│
├─ 价格合理性
│   └─ 最高价 >= 最低价？
│
└─ 异常检测
    └─ 价格突变 > 50%？
```

---

## 六、实盘执行流程

### 6.1 实盘启动流程

```
┌─────────────────────────────────────────────────────────────┐
│ TradingSystemMain.main("live")                              │
└─────────────────────────────────────────────────────────────┘

   1. 加载配置
      │
      ├─ 读取 config.properties
      ├─ API 密钥
      ├─ 代理设置（如果配置）
      └─ 风控参数
      │
      ▼
   2. 初始化交易所
      │
      ├─ 创建 Exchange 实例
      ├─ 配置代理（如果需要）
      ├─ 测试 API 连接
      └─ ⚠️ placeOrder() 未实现，需手动完成
      │
      ▼
   3. 初始化行情管理器
      │
      ├─ 初始化历史数据（1000根K线）
      ├─ 订阅 WebSocket 实时行情
      │   └─ wss://fstream.binance.com/ws/{symbol}@kline_{interval}
      ├─ 启动自动重连机制
      └─ 注册行情监听器
      │
      ▼
   4. 初始化策略引擎
      │
      ├─ 创建策略实例
      ├─ 配置风控模块
      ├─ 配置订单执行器
      └─ 启动健康检查（可选）
      │
      ▼
   5. 启动交易循环
      │
      ├─ WebSocket 推送实时K线
      ├─ MarketDataManager 更新缓存
      ├─ 通知所有策略（analyze + onPositionUpdate）
      ├─ 风控检查
      ├─ 订单执行
      └─ 持久化订单数据
```

### 6.2 WebSocket 行情处理流程

```
┌─────────────────────────────────────────────────────────────┐
│ WebSocket 实时行情推送                                      │
└─────────────────────────────────────────────────────────────┘

   Binance WebSocket Server
          │
          │ 推送 JSON 数据
          ▼
   ┌────────────────┐
   │ WebSocketClient │
   │ (OkHttp)        │
   └────────────────┘
          │
          │ 解析 JSON → KLine 对象
          ▼
   ┌────────────────┐
   │ MarketDataManager│
   │                  │
   │ 1. 更新缓存       │
   │    kLines.add(kLine)│
   │    if (size > 5000):│
   │        kLines.remove(0)│
   │                  │
   │ 2. 通知监听器     │
   │    for (listener: listeners):│
   │        listener.onKLine(kLine)│
   └────────────────┘
          │
          │ 通知策略引擎
          ▼
   ┌────────────────┐
   │ StrategyEngine  │
   │                 │
   │ processKLine() │
   └────────────────┘
```

---

## 七、监控和健康检查

### 7.1 EV 监控流程

```
┌─────────────────────────────────────────────────────────────┐
│ RollingEVCalculator                                         │
└─────────────────────────────────────────────────────────────┘

每笔交易完成后：
   │
   ├─ 更新交易窗口（最近N笔，默认100笔）
   │
   ├─ 计算统计指标：
   │   ├─ EV（期望值）= (平均盈利 × 胜率) - (平均亏损 × 败率)
   │   ├─ 胜率 = 盈利笔数 / 总笔数
   │   ├─ 平均盈利 = 总盈利 / 盈利笔数
   │   └─ 平均亏损 = 总亏损 / 亏损笔数
   │
   ├─ 持久化状态：
   │   └─ data/monitor/ev-state-{strategyId}.json
   │
   └─ 提供给健康检查器使用
```

### 7.2 策略健康检查流程

```
┌─────────────────────────────────────────────────────────────┐
│ StrategyHealthChecker                                       │
└─────────────────────────────────────────────────────────────┘

每笔交易完成后：
   │
   ├─ 获取 EV 统计数据
   │
   ├─ 检查禁用条件：
   │   │
   │   ├─ 条件1：连续亏损 >= 7笔
   │   │   └─ 禁用策略
   │   │
   │   ├─ 条件2：EV < 0 且交易数 >= 30
   │   │   └─ 禁用策略
   │   │
   │   └─ 条件3：手动禁用
   │       └─ 禁用策略
   │
   ├─ 策略状态：
   │   ├─ ENABLED：正常交易
   │   ├─ DISABLED：停止生成信号
   │   └─ 可通过配置重新启用
   │
   └─ 持久化状态：
       └─ data/monitor/health-state.json
```

---

## 八、关键注意事项

### 8.1 指标计算的正确方式

```
❌ 错误做法（不要这样做）：

private List<BigDecimal> rsiHistory = new ArrayList<>();

public void analyze(List<KLine> kLines) {
    BigDecimal rsi = new RSI(14).latest(closes);
    rsiHistory.add(rsi);  // ❌ 缓存指标值
}

public void onPositionUpdate(Position pos, KLine kLine) {
    BigDecimal currentRSI = rsiHistory.get(rsiHistory.size() - 1);  // ❌ 使用旧值
    // 问题：持仓期间RSI值永远不变！
}

✅ 正确做法：

public void onPositionUpdate(Position pos, KLine kLine, List<KLine> allKLines) {
    List<BigDecimal> closes = extractCloses(allKLines);
    BigDecimal currentRSI = new RSI(14).latest(closes);  // ✅ 实时计算
    // 持仓期间每根K线都重新计算，RSI值会实时更新
}
```

### 8.2 方法签名选择

```
Strategy 接口提供两个版本的方法：

1. 新版本（推荐）：
   onPositionUpdate(Position, KLine, List<KLine>)
   - 接收完整历史数据
   - 支持实时指标计算
   - 适用于需要技术指标的出场策略

2. 旧版本（已废弃）：
   onPositionUpdate(Position, KLine)
   - 只接收当前K线
   - 无法计算需要历史的指标
   - 适用于简单出场策略（如固定止损）
```

### 8.3 性能考虑

```
指标计算复杂度：
├─ RSI.latest(): O(n)
├─ ATR.latest(): O(n)
├─ EMA.latest(): O(n)
└─ 每根K线调用 2 次（analyze + onPositionUpdate）

总体复杂度：O(n²)

优化建议：
├─ 25920根K线 × 2次计算 = 51840次指标计算
├─ 当前实现：每根K线约需 200-500ms
├─ 总耗时：约 2-4 小时（可接受）
└─ 如果性能成为瓶颈：
    └─ 可实现指标缓存机制
        ├─ 缓存最近计算的指标值
        ├─ 新K线到达时只计算增量
        └─ 需注意缓存失效逻辑
```

---

## 九、常见场景处理

### 9.1 场景1：策略无信号

```
可能原因：
├─ 处于冷却期（3根K线内）
├─ 市场条件不满足（ATR分位数不在[30%,70%]）
├─ 进场条件不满足（RSI、EMA等条件未达成）
└─ 数据不足（少于60根K线）

解决方案：
├─ 检查日志中的"冷却期"提示
├─ 检查日志中的"ATR分位数"信息
├─ 调整策略参数（RSI阈值、ATR分位区间等）
└─ 等待更多数据积累
```

### 9.2 场景2：持仓期间出场不触发

```
可能原因：
├─ 使用了旧方法签名（无法计算指标）
├─ 出场条件设置不合理（太严格或太宽松）
└─ 持仓计数器未正确初始化

解决方案：
├─ 确认重写了新方法签名
├─ 在 onPositionUpdate 中重新计算指标
├─ 调整出场参数（持仓时间、RSI区间等）
└─ 检查日志中的"持仓X根K线"输出
```

### 9.3 场景3：回测结果异常

```
可能原因：
├─ 回测时间范围配置错误（如未来时间）
├─ 网络问题导致数据不完整
├─ 代理配置问题（无法访问API）
└─ 手续费/滑点设置不合理

解决方案：
├─ 检查 config.properties 中的时间范围
├─ 检查网络连接和代理配置
├─ 对比不同时间段的回测结果
└─ 调整手续费和滑点参数
```

---

## 十、配置参数说明

### 10.1 策略参数（HFVSStrategy）

```properties
# RSI 参数
hfvs.rsi.oversold=30          # 超卖阈值（做多信号）
hfvs.rsi.overbought=70         # 超买阈值（做空信号）
hfvs.rsi.mean.lower=45         # 均值回归下界（止盈）
hfvs.rsi.mean.upper=55         # 均值回归上界（止盈）

# EMA/ATR 参数
hfvs.ema.atr.threshold=2.0     # EMA距离阈值（ATR倍数）
hfvs.atr.stop.multiplier=2.0    # ATR止损倍数

# 时间止损
hfvs.max.holding.bars=20       # 最大持仓K线数（100分钟）

# ATR 分位适用区间
hfvs.atr.percentile.min=0.0    # 最小分位数（0%）
hfvs.atr.percentile.max=1.0    # 最大分位数（100%）
```

### 10.2 全局风控参数

```properties
# 风险控制
risk.per.trade=0.01            # 每笔风险比例（1%）
risk.max.drawdown=0.30         # 最大回撤（30%）
risk.max.consecutive.losses=5  # 最大连续亏损次数

# 策略配置
strategy.cooldown.bars=3       # 冷却期K线数（15分钟）
strategy.use.atr.stoploss=true # 使用ATR止损
```

---

## 总结

本系统的核心设计原则：

1. **数据单向流动**：MarketData → Strategy → RiskControl → Execution → Exchange
2. **分层风险控制**：策略层、全局层、紧急停止三层防护
3. **完整历史数据**：所有决策基于完整K线历史，而非单根数据
4. **实时指标计算**：持仓期间每根K线重新计算，确保决策准确
5. **向后兼容设计**：新旧策略可以共存，逐步迁移

遵循这个流程，可以安全、稳定地运行量化交易策略。
